import{_ as i,c as a,o as l,ae as n}from"./chunks/framework.Cd-3tpCq.js";const h="/assets/%E5%9E%83%E5%9C%BE%E4%BA%A7%E7%94%9F.HHvu2ddQ.png",t="/assets/%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8.CmX5Xl2-.png",p="/assets/%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8.RDjWOzI6.png",e="/assets/%E5%AD%A4%E5%B2%9B.DW2TmCdx.png",k="/assets/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%9B%BE%E8%A7%A3.BABIQJNs.png",r="/assets/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87.BXR5ue-m.png",E="/assets/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.6DxcSXOY.png",d="/assets/%E6%96%B0%E8%80%81%E7%94%9F%E4%BB%A3%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.Bll-Zhxl.png",o="/assets/%E4%BD%BF%E7%94%A8%E5%8C%BA%E7%A9%BA%E9%97%B2%E5%8C%BA.zghoImsj.png",g="/assets/%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6.DZ6TyZaR.png",c="/assets/%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0.Crsys6fQ.png",y="/assets/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95.BxQK3W-W.png",u="/assets/%E5%86%99%E5%B1%8F%E9%9A%9C.ag-kgtyS.png",F="/assets/%E5%B9%B6%E5%8F%91%E5%9B%9E%E6%94%B6.BXlhMgj-.png",A="/assets/%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83%E7%A4%BA%E4%BE%8B.lZEhHIsN.png",m="/assets/%E6%B8%B8%E7%A6%BBDOM.B2F3eNfJ.png",C="/assets/performance%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD.itLWu9fy.png",D="/assets/%E5%9C%BA%E6%99%AF%E4%B8%80.BYouKz4b.png",B="/assets/%E5%9C%BA%E6%99%AF%E4%BA%8C.CzO9Y8Ax.png",b="/assets/pmonitor1.CyKnDqZV.png",v="/assets/pmonitor2.CNdhpDCd.png",f="/assets/memory1.DcEXIChE.png",_="/assets/summary.CNdfkxz1.png",q="/assets/snapshotone.BSAmsdCH.png",S="/assets/summaryfour.vYyiYKZ3.png",j="/assets/comparsiontwo.CTS2uCCV.png",x="/assets/31.DUHKe0rc.png",w="/assets/41.DqV4rdqe.png",I=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/02JavaScript/OOM/GC&OOM.md","filePath":"frontend/02JavaScript/OOM/GC&OOM.md"}'),z={name:"frontend/02JavaScript/OOM/GC&OOM.md"};function P(M,s,O,G,J,T){return l(),a("div",null,s[0]||(s[0]=[n(`<h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><h3 id="项目背景" tabindex="-1">项目背景 <a class="header-anchor" href="#项目背景" aria-label="Permalink to &quot;项目背景&quot;">​</a></h3><ul><li>因为一直参与项目的前端工作主要是基于Electron框架的桌面前端开发，与传统的基于网页的前端开发不同的是，桌面开发对内存管理的要求更高，毕竟网页很少会有那种需要长时间保持使用的场景，但桌面应用不同了，桌面应用用户常常把应用挂在桌面，如果稍微有点内存没有管理好，存在内存泄漏的隐患，长时间积累下来，很容易内存溢出，出现应用程序白屏崩溃的问题，会导致用户的体验感非常差，所以本文主要对当前主流的JS引擎的垃圾回收机制原理以及常见内存泄漏场景及如何监控分析做个梳理与记录。</li></ul><h3 id="gc简介" tabindex="-1">GC简介 <a class="header-anchor" href="#gc简介" aria-label="Permalink to &quot;GC简介&quot;">​</a></h3><ul><li><p>垃圾回收，简称<code>GC(Garbage Collection)</code>，js引擎自带GC，代码层面相对无感，自动完成垃圾回收工作。</p><ul><li>一般高级语言都自带GC，像<code>Python</code>, <code>Java</code>, <code>Javascript</code>；当然也有不带GC，例如<code>C</code>, <code>C++</code>，需要手动管理内存</li></ul></li><li><p>因为浏览器不同，不同的JS引擎在垃圾回收机制上的一些细节及优化上略有不同，本文主要以目前市场占有率大的 V8 引擎为例说明一下。</p></li></ul><h3 id="垃圾的产生" tabindex="-1">垃圾的产生 <a class="header-anchor" href="#垃圾的产生" aria-label="Permalink to &quot;垃圾的产生&quot;">​</a></h3><ul><li>js中像Number，String等基本数据类型存储在栈内存中，而像Array，Object等引用数据类型则存储在堆内存中, 但是引用数据类型会在栈内存中存储一个实际对象的引用地址。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Linda&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    text: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+h+`" alt="" loading="lazy"></p><ul><li>从状态2中就可以看出，此时堆内存中就出现了红框打叉的“垃圾”，也就是无用的对象，如果任由其搁置，一个两个还能忍受，多了的话内存不够用就容易内存溢出<code>(OOM, Out Of Memory)</code></li></ul><h2 id="js垃圾回收" tabindex="-1">JS垃圾回收 <a class="header-anchor" href="#js垃圾回收" aria-label="Permalink to &quot;JS垃圾回收&quot;">​</a></h2><h3 id="可达性概念" tabindex="-1">可达性概念 <a class="header-anchor" href="#可达性概念" aria-label="Permalink to &quot;可达性概念&quot;">​</a></h3><ul><li><p>js中有个概念<code>可达性</code>，“可达”值是那些以某种方式<strong>可访问或可用的值</strong>，它们一定是存储在内存中的 ，注意，<strong>被引用与被访问是不同的概念</strong></p></li><li><p>几种引用情况</p><ul><li><p>单个引用</p><ul><li>就是常见的单个引用，类似上文的user对象</li></ul></li><li><p>多个引用</p></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: John</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> admin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 仍然可以通过admin访问可达，不可回收</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不可达，可回收</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">admin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span></code></pre></div><p><img src="`+t+`" alt="" loading="lazy"></p><ul><li>相互引用</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> man</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> woman</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Linda&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">man.wife </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> woman</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">woman.husband </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> man</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    father: man,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mother: woman</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除一个引用，所有对象仍然可达</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family.father;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 再删除一个引用，此时{name: John}只保留了一个对外的wife引用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对外引用不重要，只有传入引用才可以使对象可达，此时{name: John}是不可达的，将要被GC</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family.mother.husband;</span></span></code></pre></div><p><img src="`+p+`" alt="" loading="lazy"></p><ul><li>孤岛</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个例子显示了可达性概念的重要</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 虽然John和Linda仍然连着，存在引用关系，但是family已经无法访问了，即不可达，成为“孤岛”，即将GC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">family </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span></code></pre></div><p><img src="`+e+'" alt="" loading="lazy"></p></li><li><p>JS垃圾回收机制说白了其实就是<strong>定期找出不再用到的内存(不可达的对象)，然后释放其内存</strong>，这其中的重点就是如何找到无用内存并释放，这个寻找的过程涉及到一些算法策略，常见的有两种：引用计数和标记清除</p></li></ul><h3 id="回收策略" tabindex="-1">回收策略 <a class="header-anchor" href="#回收策略" aria-label="Permalink to &quot;回收策略&quot;">​</a></h3><h4 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h4><ul><li>引用计数（Reference Counting）， 比较早期的一种垃圾回收算法， 它把 <code>对象是否不再需要</code> 简化定义为 <code>对象有没有其他对象引用到它</code> ，但通过上面可达性的介绍，我们可以知道这种简单定义对很多情况都不适用，会有很多问题，目前已经很少使用这种算法了，基本算是被弃用了，不过可以简单了解一下</li><li>跟踪记录每个变量值的被使用的次数 <ul><li>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</li><li>如果同一个值又被赋给另一个变量，那么引用数加 1</li><li>如果该变量的值被其他的值覆盖了，则引用次数减 1</li><li>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</li></ul></li></ul><h4 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h4><ul><li>标记清除（Mark-Sweep），目前在 <code>JS引擎</code> 里这种算法是最常用的，主要包含<code>标记</code>和<code>清除</code>两个阶段</li><li>算法过程 <ul><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0(白色)</li><li>然后从各个根对象开始遍历，把不是垃圾的节点改成1(黑色)</li><li>清理所有标记为0(白色)的垃圾，销毁并回收它们所占用的内存空间</li><li>最后，把所有内存中对象标记修改为0(白色)，等待下一轮垃圾回收</li></ul></li><li>整个过程看起来就像泼了一桶油漆一样逐渐蔓延开来。</li></ul><p><img src="'+k+'" alt="" loading="lazy"></p><ul><li>优化 - 标记整理 (Mark-Compact) <ul><li><p>原始的标记清除在清除之后剩余的对象位置不变导致空闲内存不连续，会造成<code>内存碎片</code>问题，从而后续内存分配速度慢</p><p><img src="'+r+'" alt="" loading="lazy"></p></li><li><p>它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存</p><p><img src="'+E+'" alt="" loading="lazy"></p></li></ul></li></ul><h3 id="v8对gc的优化" tabindex="-1">V8对GC的优化 <a class="header-anchor" href="#v8对gc的优化" aria-label="Permalink to &quot;V8对GC的优化&quot;">​</a></h3><h4 id="优化点一-分代式垃圾回收" tabindex="-1">优化点一：分代式垃圾回收 <a class="header-anchor" href="#优化点一-分代式垃圾回收" aria-label="Permalink to &quot;优化点一：分代式垃圾回收&quot;">​</a></h4><p><img src="'+d+'" alt="" loading="lazy"></p><ul><li>新生代 - <strong>新</strong>、<strong>小</strong>、存活时间<strong>短</strong>的对象</li></ul><p><img src="'+o+'" alt="" loading="lazy"></p><ul><li>老生代 - <strong>老</strong>、<strong>大</strong>、存活时间<strong>长</strong>的对象 <ul><li>整个过程其实就是上述的标记 - 整理 -清除的过程</li></ul></li><li>使用分代式的原因 - 新生代采用一小块内存频率较高的快速清理，老生代则很少接受检查，新老生代的回收机制及频率是不同的，很大程度提高了垃圾回收机制的效率</li></ul><h4 id="优化点二-并行回收-parallel" tabindex="-1">优化点二：并行回收(Parallel) <a class="header-anchor" href="#优化点二-并行回收-parallel" aria-label="Permalink to &quot;优化点二：并行回收(Parallel)&quot;">​</a></h4><ul><li><code>全停顿(stop-the-world)</code>行为 <ul><li>JS是一个运行在主进程上的单线程语言，进行垃圾回收就会阻塞JS脚本的执行，需等待垃圾回收执行完成再恢复JS脚本的运行；那如果一次全停顿时间过长，就会造成页面卡顿等问题。</li></ul></li><li>垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作，实现并行回收。<strong>(有空补充细化一下)</strong></li></ul><p><img src="'+g+'" alt="" loading="lazy"></p><ul><li>并行策略对于<strong>新生代</strong>垃圾回收器能够有很好的优化，在执行垃圾回收的过程中，会启动多个线程来负责新生代中的垃圾清理操作，但本质上它还是一种全停顿式的垃圾回收方式，但对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 <code>GC</code> 时哪怕我们使用并行策略依然可能会消耗大量时间。</li></ul><h4 id="优化点三-增量标记与懒性清理" tabindex="-1">优化点三：增量标记与懒性清理 <a class="header-anchor" href="#优化点三-增量标记与懒性清理" aria-label="Permalink to &quot;优化点三：增量标记与懒性清理&quot;">​</a></h4><ul><li><p><strong>增量标记</strong>就是原先完整的一次GC标记过程分成好几步标记过程，与JS脚本执行交替进行完成一轮GC标记。</p><p><img src="'+c+'" alt="" loading="lazy"></p><ul><li><p>暂停与修复 - <strong>三色标记法</strong></p><ul><li>使用每个对象的<strong>两个标记位和一个标记工作表</strong>来实现标记，两个标记位编码三种颜色：白、灰、黑 <ul><li>白色指的是未被标记的对象</li><li>灰色指自身被标记，成员变量（该对象的引用对象）未被标记</li><li>黑色指自身和成员变量皆被标记</li></ul></li></ul><p><img src="'+y+'" alt="" loading="lazy"></p></li><li><p>引用修改 - <strong>写屏障(write barrier)</strong></p><p><img src="'+u+'" alt="" loading="lazy"></p></li></ul></li><li><p>惰性清理(Lazy Sweeping)</p><ul><li>内存不紧张时优先JS脚本的执行</li><li>按需清理，不一定非要一次性清理完</li></ul></li><li><p>增量标记+惰性清理使得全停顿时间大大减少，交互更加流畅，但是缺点也非常明显：(1)主线程总的暂停时间并没有减少甚至会有所增加；(2)引入写屏障机制会降低应用程序的吞吐量；</p></li></ul><h4 id="优化点四-并发回收" tabindex="-1">优化点四： 并发回收 <a class="header-anchor" href="#优化点四-并发回收" aria-label="Permalink to &quot;优化点四： 并发回收&quot;">​</a></h4><ul><li><p>主线程执行JS脚本的过程，辅助线程也可以在后台执行GC工作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起</p><p><img src="'+F+'" alt="" loading="lazy"></p></li><li><p>实现上更有难度，需要额外的读写锁机制来控制主线程在执行 JS时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记都要有所改变的问题。</p></li></ul><h2 id="内存泄漏-内存溢出" tabindex="-1">内存泄漏&amp;内存溢出 <a class="header-anchor" href="#内存泄漏-内存溢出" aria-label="Permalink to &quot;内存泄漏&amp;内存溢出&quot;">​</a></h2><h3 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><ul><li>内存泄漏(Memory Leak) <ul><li>指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，无法GC</li></ul></li><li>内存溢出(Out of Memory) <ul><li>指程序在申请内存时，没有足够的内存空间供其使用</li></ul></li><li>二者的关系 <ul><li>内存溢出会抛出异常，内存泄露不会抛出异常，大多数时候程序看起来是正常运行的</li><li>一次内存泄漏可能不会有很大的影响，但长时间的内存泄漏，堆积到一定程度就会产生内存溢出。</li></ul></li></ul><h3 id="典型场景" tabindex="-1">典型场景 <a class="header-anchor" href="#典型场景" aria-label="Permalink to &quot;典型场景&quot;">​</a></h3><h5 id="不正当闭包" tabindex="-1">不正当闭包 <a class="header-anchor" href="#不正当闭包" aria-label="Permalink to &quot;不正当闭包&quot;">​</a></h5><ul><li><p>什么是闭包？</p><ul><li>正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 <code>[[Environment]]</code> 属性和词法环境原理的技术细节。</li><li><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noreferrer">闭包</a>是指一个函数可以记住其外部变量并可以访问这些变量。</li><li>在 JavaScript 中，每个运行的函数，代码块 <code>{...}</code> 以及整个脚本，都有一个被称为 <strong>词法环境（Lexical Environment）</strong> 的内部（隐藏）的关联对象，该对象由两部分组成：</li><li><strong>环境记录（Environment Record）</strong> —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象 。</li><li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联。</li><li>词法环境图示</li><li>所有的函数在“诞生”时都会记住创建它们的词法环境：所有函数都有名为 <code>[[Environment]]</code> 的隐藏属性，该属性保存了对创建该函数的词法环境的引用，基本上JavaScript 中的所有函数都是闭包，有个个例就是<code>new Function</code>形式，这里就不赘述了。</li><li><strong>当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</strong> 可参考下图理解：</li></ul><p><img src="'+A+`" alt="" loading="lazy"></p></li><li><p>使用闭包一定会造成内存泄漏？</p><ul><li>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。 但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的 <code>[[Environment]]</code> 属性。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 情况1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 情况2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 嵌套函数被删除后，其封闭的词法环境（以及其中的 value）也会被从内存中删除</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当 g 函数存在时，该值会被保留在内存中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ……现在内存被清理了</span></span></code></pre></div></li></ul><h5 id="定时器未及时清理" tabindex="-1">定时器未及时清理 <a class="header-anchor" href="#定时器未及时清理" aria-label="Permalink to &quot;定时器未及时清理&quot;">​</a></h5><ul><li>setTimeout 、 setInterval 是由浏览器专门线程来维护它的生命周期，其生命周期与页面的生命周期并不同步，所以如果在当前页面的 js 里通过定时器注册了某个回调函数，而该回调函数内又持有当前页面某个变量或某些 DOM 元素时，就会导致即使页面销毁了，由于定时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏了。</li><li>const timer = setTimeout(callback, time) <ul><li>有限次使用：可以使用<code>clearTimeout(timer)</code>在还未开始执行的时候取消<code>setTimoeout</code>，而在执行完成之后调用<code>clearTimeout</code>没有坏处，但其实是一个无效操作，并不会因为执行完没调用<code>clearTimeout</code>而引起内存泄漏的问题;</li><li>递归使用：有必要在每次创建一个新的setTimout之前调用clearTimout清除上一个setTimeout的影响</li></ul></li><li>const timer = setInterval(callback, time) <ul><li>项目中除了常驻<code>setInterval</code>的场景，使用<code>setInterval</code>一定要在恰当时机调用<code>clearInterval(timer)</code>，不同于<code>setTimeout</code>，<code>setInterval</code>不主动清除的话会一直重复调用</li></ul></li><li>浏览器中的 <code>requestAnimationFrame</code> 也存在这个问题，需要在不需要的时候用 <code>cancelAnimationFrame</code> API 来取消使用。</li></ul><h5 id="事件监听重复注册" tabindex="-1">事件监听重复注册 <a class="header-anchor" href="#事件监听重复注册" aria-label="Permalink to &quot;事件监听重复注册&quot;">​</a></h5><ul><li>重复绑定相同的事件处理函数，如果不主动清除释放掉，处理函数中引用的变量或者是函数都会被认为是需要的而不会被回收，造成内存泄漏，正在参与的项目中常见的需要绑定事件处理函数的主要包含以下三种形式： <ul><li>ipc通信(主进程/渲染进程) <ul><li>(ipcMain/ipcRenderer).on(evetName, eventHandler)</li><li>(ipcMain/ipcRenderer).<strong>removeListener</strong>(evetName, eventHandler) <ul><li>注意eventHandler不建议是匿名函数，否则无法remove掉</li></ul></li></ul></li><li>JS中的事件监听器 <ul><li>window. addEventListener(&quot;resize&quot;, this.doSomething)</li><li>window.<strong>removeEventListener</strong>(&quot;resize&quot;, this.doSomething)</li></ul></li><li>BUS通信 <ul><li>BUS.on(evetName, eventHandler)</li><li>BUS.<strong>off</strong>(evetName, eventHandler)</li></ul></li></ul></li></ul><h5 id="未清理的console日志" tabindex="-1">未清理的console日志 <a class="header-anchor" href="#未清理的console日志" aria-label="Permalink to &quot;未清理的console日志&quot;">​</a></h5><ul><li><p>之所以在控制台能看到数据输出，是因为浏览器保存了我们输出对象的信息数据引用，也正是因此未清理的 <code>console</code> 如果输出了对象也会造成内存泄漏。所以，最好不要在页面中console.log任何大对象，这样可能会影响页面的整体性能，特别在生产环境中。除了console.log外，另外还有console.dir、console.error、console.warn等都存在类似的问题，这些细节需要特别的关注。开发环境下我们可以使用控制台输出来便于我们调试，但是在生产环境下，一定要及时清理掉输出。</p></li><li><p>解决方案</p><ul><li>方案一：main.js中添加以下代码</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正式环境清除所有console.log</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NODE_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;production&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (window) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><p>方案二：推荐使用<code>terser-webpack-plugin</code>插件，配置生产环境中删除所有console输出</p><ul><li>安装插件指令</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">npm install terser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">webpack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">plugin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">save</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dev</span></span></code></pre></div><ul><li>添加webpack配置，参与的项目主要是在vue.config.js文件中配置</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TerserPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;terser-webpack-plugin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  configureWebpack: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    optimization: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minimize: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NODE_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;production&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//为了不影响dev时的构建速度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minimizer: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TerserPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          parallel: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用多进程并发运行以提高构建速度 Boolean|Number 默认值： true </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          terserOptions: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            compress: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              drop_console: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//移除所有console相关代码；</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              drop_debugger: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//移除自动断点功能；</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              pure_funcs: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;console.log&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;console.error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//配置移除指定的指令，如console.log,alert等</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            format: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              comments: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//删除注释</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          extractComments: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//是否将注释剥离到单独的文件中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul></li></ul><h5 id="dom引用游离" tabindex="-1">DOM引用游离 <a class="header-anchor" href="#dom引用游离" aria-label="Permalink to &quot;DOM引用游离&quot;">​</a></h5><ul><li>当我们使用变量缓存 DOM 节点引用后删除了节点，如果不将缓存引用的变量置空，依然进行不了 GC，也就会出现内存泄漏。</li><li>假如我们将父节点置空，但是被删除的父节点其子节点引用也缓存在变量里，那么就会导致整个父 DOM 节点树下整个游离节点树均无法清理，还是会出现内存泄漏，解决办法就是将引用子节点的变量也置空</li><li>代码示例</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// html结构</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;root&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ul&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;li3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JS获取DOM引用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#root&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ul </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#ul&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> li3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#li3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由于ul变量存在，整个ul及其子元素都不能GC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ul)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ul </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 已无变量引用，此时可以GC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">li3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span></code></pre></div><ul><li>上述图解</li></ul><p><img src="`+m+`" alt="" loading="lazy"></p><h5 id="隐式全局变量" tabindex="-1">隐式全局变量 <a class="header-anchor" href="#隐式全局变量" aria-label="Permalink to &quot;隐式全局变量&quot;">​</a></h5><ul><li>对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以全局变量通常不会被回收，我们使用全局变量是可以的，但要注意避免一些额外的全局变量产生， 在开发中我们可以使用严格模式或者通过 <code>lint</code> 检查来避免这些情况的发生 ；</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 没有声明从而制造了隐式全局变量test1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  test1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;isboyjc1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 函数内部this指向window，制造了隐式全局变量test2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.test2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;isboyjc2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><ul><li>同时当我们在使用全局变量存储数据时，要确保使用后将其置空或者重新分配，使用完将其置为 <code>null</code> 即可，特别是在使用全局变量做持续存储大量数据的缓存时，一定要记得设置存储上限并及时清理，不然的话数据量越来越大，内存压力也会随之增高。</li></ul><h5 id="遗忘的map、set对象" tabindex="-1">遗忘的Map、Set对象 <a class="header-anchor" href="#遗忘的map、set对象" aria-label="Permalink to &quot;遗忘的Map、Set对象&quot;">​</a></h5><ul><li><p><code>Map</code>或<code>Set</code>与<code>Object</code>一样都是强引用，如果不主动清除引用同样会造成内存不自动GC</p><ul><li>强引用 - 持有一个不会被GC的引用即强引用，</li><li>弱引用 - 若一个对象只是被弱引用所引用则被认为是不可访问的(或弱可访问的)，因此可能在任何时刻被回收</li></ul></li><li><p>对于键为对象的情况，<code>Map</code>可以采用<code>WeakMap</code>，对于键是弱引用，且键必须是对象，但是值可以使任意的对象和原始值；如果需要使用<code>Set</code>引用对象，可以采用<code>WeakSet</code>，允许存储对象弱引用的唯一值；<code>WeakMap</code>、<code>WeakSet</code>由于弱引用，不会干扰js的垃圾回收。</p></li><li><p>代码示例</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// obj是一个强引用，对象存于内存，可用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重写obj引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对象从内存移除，回收 {id: 1} 对象</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {info: obj}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> set </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([obj])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([[obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hahaha&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重写obj,{id:1}依然存在于内存中，因为user、set、map都强引用了它，如果想要清除需要置空所有引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user.info) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {id: 1}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(map)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weakSet </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([obj])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weakMap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeakMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([[obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hahaha&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 重写obj引用，置空之后，对象{id:1}将在下一次GC中被清理，而不需要我们上面的代码一样手动置空所有的引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {id: 1} 将在下一次 GC 中从内存中删除</span></span></code></pre></div></li></ul><h2 id="监控与分析" tabindex="-1">监控与分析 <a class="header-anchor" href="#监控与分析" aria-label="Permalink to &quot;监控与分析&quot;">​</a></h2><ul><li><p>接下来以一个典型的内存泄漏的代码示例来走一遍如何借助<code>Chrome Devtool</code>工具排查定位内存泄漏根源并进行修复的完整流程，主要有两个场景代码，代码示例如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 场景一</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 点击按钮，就执行一次函数，申请一块内存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 场景二</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 点击按钮，就执行一次函数，申请一块内存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul><h5 id="排查" tabindex="-1">排查 <a class="header-anchor" href="#排查" aria-label="Permalink to &quot;排查&quot;">​</a></h5><ul><li><p>打开任意一个网页，按<code>f12</code>打开控制台即 <code>Chrome Devtool</code> ，点击切换到<code>Performance</code>面板，原先这个面板叫做<code>Timeline</code>, 是 <code>Chrome Devtool</code> 用来监控性能指标的一个利器，可以记录并分析在网站的生命周期内所发生的各类事件，我们就可以通过它监控我们程序中的各种性能情况并分析，其中就包括内存，简单介绍一下基础功能有：</p><p><img src="`+C+'" alt="" loading="lazy"></p></li><li><p>在确保<code>Memeory</code>选项已勾选的情况下，分别对场景一和场景二进行相同操作：点击开始录制（标记 1）进入录制状态，随后先清理一下GC，也就是点击小垃圾桶（标记 6）。接着连续点击页面中 <code>click</code> 按钮 50 次，再点击一下小垃圾桶，手动触发一次 GC。再次连续点击页面中 <code>click</code> 按钮 50 次，然后停止录制，观察两次的面板数据，得到下面两张图：</p><ul><li><p>场景一</p><p><img src="'+D+'" alt="" loading="lazy"></p><ul><li>函数内部使用局部变量，函数执行完毕，这块内存没用就可以被回收了。当短时间内不断调用该函数时，下一个函数执行时，发现内存不足，GC启动，回收上一个函数申请的内存，因为上一个函数执行结束，内存无用能够被回收了，反映在面板图表上基本上就是一条横线过去，中间出现多处竖线，其实就是表示内存清空，再申请，清空再申请，每个竖线的位置就是垃圾回收机制工作以及函数执行又申请内存的时机。</li></ul></li><li><p>场景二</p><p><img src="'+B+'" alt="" loading="lazy"></p><ul><li>观察一下与场景一的区别：不再是一条横线了，而且横线中的每个竖线的底部也不是同一水平了，其实这就是内存泄漏了，场景二的函数内申请了两个数组内存，但其中有个数组却被外部变量arr持有，造成即使每次函数执行完，这部分被外部持有的数组内存也依旧回收不了，每次只能回收一部分内存，当函数调用次数增多时，没法回收的内存就越多，内存泄漏的也就越多，导致内存使用量一直在增长。</li></ul></li><li><p>也可以使用 <code>performance monitor</code> 工具，在控制台界面里找到更多<code>...</code>的按钮，在里面打开此功能面板，可以实时监控 cpu，内存等使用情况的工具，会<code>performance</code>面板更直观一点。</p><p><img src="'+b+'" alt="" loading="lazy"></p><p><img src="'+v+'" alt="" loading="lazy"></p></li></ul></li></ul><h5 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h5><ul><li><p>明确了是出现内存泄漏问题之后，接下来借助<code>Memory</code>面板来分析定位具体泄漏的源头在哪里，该面板基础功能有：</p><p><img src="'+f+'" alt="" loading="lazy"></p><p>利用这些工具可以分析出什么时刻是由于哪个函数操作导致了内存分配，分析出大量重复且没有被回收的对象是什么，在有了嫌疑的函数和对象后再回到相关代码中分析一下这个函数里的这个对象到底是不是就是内存泄漏的元凶。</p></li><li><p>以Heap snapshot分析类型为例</p><ul><li><p>单独查看某个时刻快照</p><p>内存分析类型勾选第一个，可以先手动触发一下GC(标记3)， 然后点击页面的click按钮2次，再点击生成快照(标记1)，得到一个<code>Snapshot 1</code>结果：</p><p><img src="'+_+'" alt="" loading="lazy"></p><p><code>Constructor</code> 这一列是构造函数，每一个构造函数点击都可以查看由该构造函数创建的所有对象，并不是所有构造函数都需要关注，先简单介绍下此列中常见的构造函数大致代表什么内容：</p><p>(1)system、system/Context 表示引擎自己创建的以及上下文创建的一些引用，这些不用太关注，不重要</p><p>(2)closure 表示一些函数闭包中的对象引用</p><p>(3)array、string、number、regexp 这一系列也能看出，就是引用了数组、字符串、数字或正则表达式的对象类型</p><p>(4)HTMLDivElement、HTMLAnchorElement、DocumentFragment等等这些其实就是你的代码中对元素的引用或者指定的 DOM 对象引用</p><p>对个单个快照的分析可以从内存占用比例来查看占据大量内存的是什么对象从而定位源头，也是一种思路，点击<code>Retained size</code>进行排序，发现除了system，内存占比最大的就是(array)，展开(array) 选中<code>object elements</code>，就可以得到详细信息，发现这个内存占用出现在leak.html的第19行，返回代码分析分析代码逻辑确认是真的内存泄漏了还是单纯就是需要这么多内存。</p><p><img src="'+q+'" alt="" loading="lazy"></p></li><li><p>对比查看两个时刻快照</p><p>可以抓取两份快照，两份快照中间进行内存泄漏操作，最后再比对两份快照的区别，查看增加的对象是什么，回收的对象又是哪些，具体的操作可以是在已有的<code>Snapshot 1</code>的基础上，再点击页面的click按钮2次，再点击生成快照(标记1)，又得到了一个<code>Snapshot 2</code>结果，如何进行快照之间的对比，可以关注一下视图表格左上方的下拉框</p><p><img src="'+S+'" alt="" loading="lazy"></p><p>选中<code>Snapshot 2</code>，再点击选择Comparison选项，会自动与上一个快照进行对比，也可以点击下图所示的下拉框进行切换</p><p><img src="'+j+'" alt="" loading="lazy"></p><p>可以看到视图表格上方有好几个指标，有几个指标简单介绍一下：<code>New</code> - 新建了多少个对象；<code>Deleted</code> - 回收了多少个对象；<code>Delta</code> - 新建的对象数 减去 回收的对象数；重点关注 <code>Delta</code> 指标，只要它是正数就可能存在问题，而且控制台都已经排好序了，非常方便，依次从上往下看就行。 点击展开<code>Delta</code>为正数2的(array)，点击其中一个内容，视图表格下方就会显示具体信息，其中还包括这个对象所在的文件名称和代码行数，此时回归到具体代码中分析，发现存在数组的引用是完全因为场景二代码中那个全局数组变量 <code>arr</code> 的存在，毕竟每次点击都会 <code>push</code> 进一份变量<code>b</code>的数据，这也是上面提到的为什么要额外关注全局变量的使用、要将它及时清理之类的，就是可能会存在这种情况，不清理的话这些全局变量在页面关闭前就一直在内存里，内存还会一直越来越大。</p><p>此时我们好像知道了内存泄漏源头在哪儿了，我们可以再多进行几次快照验证一下，在页面点击click按钮2次得到<code>Snapshot 3</code>，再点2次得到<code>Snapshot 4</code>, 依次与<code>Snapshot 1</code>进行对比，得到如下两张结果：</p><p><img src="'+x+'" alt="" loading="lazy"></p><p><img src="'+w+'" alt="" loading="lazy"></p><p>从红框中可以发现，每点一次click按钮，执行完一次函数，就会增加一个对象，符合<code>arr.push(b)</code>的逻辑，泄露的根源可以确定在这儿。</p><p>分析定位成功，进入下一步骤，修复并再次验证。</p></li></ul></li></ul><h5 id="修复" tabindex="-1">修复 <a class="header-anchor" href="#修复" aria-label="Permalink to &quot;修复&quot;">​</a></h5><p>由于本文的案例比较简单，没有啥复杂的场景，也不是具体的场景，所以也就没有办法使用针对性的方式来修复，一切都需要根据具体场景选择解决方案，解决之后重复上面排查流程看内存即可。类似这个全局数组一直增大这个问题，全局对象无法避免，但是可以限制一下全局对象的大小，根据场景可以超出就清理一部分。</p>',66)]))}const L=i(z,[["render",P]]);export{I as __pageData,L as default};
