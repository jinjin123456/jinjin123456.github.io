import{_ as e,c as a,o as t,R as o}from"./chunks/framework.BmksyVjO.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/06前端工程化/前端Gitlab工作流.md","filePath":"frontend/06前端工程化/前端Gitlab工作流.md"}'),r={name:"frontend/06前端工程化/前端Gitlab工作流.md"},l=o('<h3 id="常规模式" tabindex="-1">常规模式 <a class="header-anchor" href="#常规模式" aria-label="Permalink to &quot;常规模式&quot;">​</a></h3><p>每个人都工作在同一分支下。</p><p>比如远程分支 <code>origin/dev</code>，每人都在本地的 <code>dev</code> 上工作，拉取、推送代码。</p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><p>操作简单，与 <code>svn</code> 类似，一般情况下只需要处理 <code>pull</code>、<code>add</code>、<code>commit</code>、<code>push</code> 这几个操作。</p><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ol><li>由于是多人协作，当 <code>pull</code>、<code>push</code> 操作频繁的时候，会产生大量 &quot;merge branch &#39;dev&#39; of XXX URL into dev&quot; 的额外 <code>commit</code>；</li><li>前面频繁合并导致分支图表时间线非常混乱，不利于管理；</li><li>不利于进行权限控制和代码评审，可能出现手误提交错误的代码；</li><li>与构建和上线流程契合度低，紧急修复、过往版本管理操作繁琐；</li></ol><h3 id="基于-git-rebase-和-merge-request-的改进" tabindex="-1">基于 git rebase 和 merge-request 的改进 <a class="header-anchor" href="#基于-git-rebase-和-merge-request-的改进" aria-label="Permalink to &quot;基于 git rebase 和 merge-request 的改进&quot;">​</a></h3><p>这种方式的核心在于：</p><p>使用 <code>git rebase</code> 操作代替 <code>pull</code> 或者 <code>merge</code> 操作，减少上述多余 <code>commit</code> 信息的产生。同时，<code>rebase</code> 可以合并 <code>commit</code>，将多个细粒度的合并为单个粗粒度的 <code>commit</code>，进一步简化时间线。</p><p>更多关于 <code>rebase</code> 的资料：<a href="https://www.codercto.com/a/45325.html" target="_blank" rel="noreferrer">https://www.codercto.com/a/45325.html</a></p><p>使用 Gitlab 平台提供的 merge request 功能代替 <code>push</code> 操作。这个功能讲代码开发和代码合并进行了角色分离（可以是同一个人），在此基础上，可以方便地进行权限控制、代码评审等操作。</p><p>merge request 不是 Git 的标准功</p><p>能，而是 Gitlab 平台提供，类似 GitHub 的 pull request，不同之处在于 merge request 基于分支，而 pull request 基于仓库。merge request的操作比较简单，可以前往 <a href="https://git.iflytek.com/" target="_blank" rel="noreferrer">https://git.iflytek.com/</a> 自行尝试。</p><h3 id="gitlab-工作流" tabindex="-1">Gitlab 工作流 <a class="header-anchor" href="#gitlab-工作流" aria-label="Permalink to &quot;Gitlab 工作流&quot;">​</a></h3><p>基于上述讨论，初步形成了Gitlab 工作流的基本架构。</p><h4 id="核心分支" tabindex="-1">核心分支 <a class="header-anchor" href="#核心分支" aria-label="Permalink to &quot;核心分支&quot;">​</a></h4><p>一个项目的仓库，分为三个核心分支：</p><ul><li>master，主分支，测试通过且上线时，将 release 分支合并到此分支；</li><li>release，构建/测试分支，每次构建版本时，将 dev 分支合并到此分支；</li><li>dev，默认分支，日常开发都在这个分支进行；</li></ul><p>上述三个分支<strong>任何人</strong>都是没有 <code>push</code> 权限，所有的改动 <strong>能且只能</strong> 通过 merge request 进行。</p><p>而且，根据规则，master 分支将会十分稳定，严格对应线上版本；release 分支比较稳定，严格对应构建的测试版本；dev 分支比较不稳定，功能不完善。</p><h4 id="开发" tabindex="-1">开发 <a class="header-anchor" href="#开发" aria-label="Permalink to &quot;开发&quot;">​</a></h4><p>在 dev 分支的基础上，会产生两类分支：</p><ul><li>一种是开发人员个人分支，用户日常零散功能的迭代或优化，推荐是用<strong>域账号</strong>进行命名；</li><li>另一种是与功能或者修复相关的 feature/xxx 或者 fix/xxx 的分支，推荐功能开发周期长、代码量多的时候采用，类似sub develop，可以进一步派生开发人员个人分支。</li></ul><p>新产生的个人、功能、修复分支都通过 merge request 方式合并到 develop。</p><h4 id="标签" tabindex="-1">标签 <a class="header-anchor" href="#标签" aria-label="Permalink to &quot;标签&quot;">​</a></h4><p>在构建版本和上线的时候，建议在特定分支打上标签。</p><p>构建版本时，在 release 分支上打构建标签，命名：<strong>build-[ 构建号 ]</strong>，比如 build-1001；</p><p>上线版本时，在 master 分支上打上线标签，命名：<strong>v[ 版本号 ]</strong>，比如 v1.2.4；</p><h4 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to &quot;流程&quot;">​</a></h4><ol><li>从 dev 分支检出（checkout）个人分支或者功能分支，比如 <em>junmei</em>；</li><li>在自己的分支上开发，然后正常的提交（commit），可重复多次；</li><li>变基（rebase）到 dev 分支： <ol><li>提交（commit）或者暂存（stash）当前分支未提交的修改；</li><li>检出（checkout）到 dev 分支，然后拉取（pull）最新</li><li>切换回个人分支，执行变基（rebase）到 dev分支，命令：<code>git rebase dev</code>；</li><li>如果有冲突，按照提示依次解决；</li></ol></li><li>推送个人分支到远程，切勿在变基前推送！</li><li>在 Gitlab 网页后台发起 merge request；</li><li>管理员在Gitlab 网页后台处理 merge request，合并代码；</li><li>[可选] 合并之后，dev 会产生一个新的提交：”merge branch &#39;junme&#39; into &#39;dev&#39;“，可以重复步骤3和4 使得 个人分支和 dev 分支完全一致；</li></ol><blockquote><p>Tips: 为了提升效率，一般情况下主要开发人员都拥有合并权限，务必谨慎操作，最好多花几分钟时间 review 一下代码。新加入的开发人员初期建议不开通合并权限，由其他人代为评审和合并，熟练后再开通相应权限。</p><p>Tips：发起merge request时可以选择<code>squash</code>，将多个 commit 合并为一个。</p></blockquote><h4 id="热修复" tabindex="-1">热修复 <a class="header-anchor" href="#热修复" aria-label="Permalink to &quot;热修复&quot;">​</a></h4><p>构建预发布或者上线后，可能会存在一些重要紧急的问题需要热修复，这时候往往不适合用 dev 分支进行修改。</p><p>一般通过检出热修复分支单独修复上线，然后使用遴选（cherry-pick）将修改同步到 dev 分支。</p>',35),i=[l];function d(c,s,n,h,p,u){return t(),a("div",null,i)}const g=e(r,[["render",d]]);export{b as __pageData,g as default};
