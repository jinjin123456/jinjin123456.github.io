import{_ as t,c as u,o as r,ae as a,j as l,a as i}from"./chunks/framework.Cd-3tpCq.js";const p=JSON.parse('{"title":"概述","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/02JavaScript/js数据类型梳理.md","filePath":"frontend/02JavaScript/js数据类型梳理.md"}'),n={name:"frontend/02JavaScript/js数据类型梳理.md"};function s(o,e,d,m,c,h){return r(),u("div",null,e[0]||(e[0]=[a('<h1 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h1><ul><li>JavScript有8种基本类型，7种原始类型和1种引用类型 <ul><li>Number</li><li>BigInt</li><li>String</li><li>Boolean</li><li>null</li><li>undefined</li><li>Symbol</li><li>Object</li></ul></li></ul><h2 id="类型判断" tabindex="-1">类型判断 <a class="header-anchor" href="#类型判断" aria-label="Permalink to &quot;类型判断&quot;">​</a></h2><ul><li>typeof <ul><li>注意特例 <ul><li>typeof null // &#39;object&#39;, 历史原因</li><li>typeof alert // &#39;function&#39;</li></ul></li></ul></li><li>Obejct.prototype.toString.call() <ul><li>Obejct.prototype.toString.call({}) &#39;[[object Object]]&#39;</li></ul></li></ul><h2 id="转换与比较" tabindex="-1">转换与比较 <a class="header-anchor" href="#转换与比较" aria-label="Permalink to &quot;转换与比较&quot;">​</a></h2><h3 id="类型转换" tabindex="-1">类型转换 <a class="header-anchor" href="#类型转换" aria-label="Permalink to &quot;类型转换&quot;">​</a></h3><ul><li>原始类型转换 <ul><li>字符串转换 <ul><li>隐式转换 <ul><li>比如在alert()方法中自动转换</li></ul></li><li>显示转换 - String() <ul><li>let num = 123; let str = Sting(num); // str - &#39;123&#39;</li></ul></li></ul></li><li>数字转换 <ul><li>隐式转换 - 在算数函数和表达中会自动进行转换</li><li>显示转换 - Number()</li><li>转换规则 <ul><li>undefined - NaN</li><li>null - 0</li><li>true - 1; fasle - 0</li><li>string <ul><li>去掉首尾空白字符后的纯数字字符串中含有的数字</li><li>如果剩余字符串为空则转换结果为0，否则将从剩余字符串中读取数字，当类型转换出现error时返回NaN。 <ul><li>Number(&quot; 123 &quot;) // 123</li><li><strong>Number(&#39;&#39;) // 0</strong></li><li><strong>Number(&#39; &#39;) //0</strong></li><li>Number(&#39;45ffs&#39;) // NaN</li><li>Number(true) // 1</li></ul></li></ul></li></ul></li></ul></li><li>布尔值转换 <ul><li>隐式转换</li><li>显示转换 - Boolean()</li><li>转换规则 <ul><li>0， null， undefined，NaN, &#39;&#39;(空字符串)都被视作fasle</li><li>其他均是true，<strong>注意任何非空字符串都是true</strong><ul><li>这里有两个误区，&#39; &#39;(空格字符串)，&#39;0&#39;(0字符串)是被视作true <ul><li><strong>Boolean(&#39; &#39;) // true</strong></li><li><strong>Boolean(&#39;&#39;) // false</strong></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>对象-原始转换 <ul><li>对象到原始值的转换，是由许多期望以原始值作为返回的内建函数和运算符自动调用的</li><li>转换算法 <ul><li>调用<code>obj[Symbol.toPrimitive](hint) </code>，如果这个方法存在 <ul><li>hint三种类型： string、number、default</li></ul></li><li>hint是string的情况，尝试调用toString()或者valueOf()，无论那个方法存在</li><li>hint是number/default的情况，尝试调用valueOf()或者toString()，无论那个方法存在</li><li>必须返回一个原始值才能工作</li></ul></li><li>实际调用中，通常只实现toString()作为字符串转换的“全能”方法就可以了，返回“人类可读”表示，用于日志和调试。</li></ul></li></ul><h3 id="值比较" tabindex="-1">值比较 <a class="header-anchor" href="#值比较" aria-label="Permalink to &quot;值比较&quot;">​</a></h3><ul><li>原始类型 <ul><li>同类型比较 <ul><li>比较运行符始终返回布尔值</li><li>在进行字符串的比较时，会按照“字典”顺序逐字符比较大小</li></ul></li><li>不同类型之间 <ul><li>JavaScript对于不同类型之间的比较会首先进行类型转换，但有几个特殊的点需要注意 <ul><li>严格相等**===**不会进行类型转换</li><li>相等性检查**==** <ul><li>null === undefined返回true，但null，undefined除了自身是不等于其他任何值的</li><li>相等性检查与&gt;,&lt;,&gt;=,&lt;=的处理方式相互独立的，这样会有很奇怪的现象 <ul><li>null &gt; 0 // false</li><li>null == 0 // false 这里属于相等性检查，null， undefined特殊处理</li><li>null &gt;= 0 // true 这里属于比较大小，会首先将null转换成数字0</li><li>undefined &gt; 0 // false</li><li>undefined == 0 // false</li><li>undefined &lt; 0 // false</li><li>null == null, undefined == undefined // true</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>引用类型</li></ul><h2 id="原始类型的方法" tabindex="-1">原始类型的方法 <a class="header-anchor" href="#原始类型的方法" aria-label="Permalink to &quot;原始类型的方法&quot;">​</a></h2><h3 id="与对象方法的区别" tabindex="-1">与对象方法的区别 <a class="header-anchor" href="#与对象方法的区别" aria-label="Permalink to &quot;与对象方法的区别&quot;">​</a></h3><ul><li>原始数据类型除了null、undefined都提供了很多有用的方法，但它≠对象！</li><li>原始类型使用方法的过程 <ul><li>字符串str是一个原始类型，当访问其属性或方法时候，会临时创建一个对象包装器，并提供可调用的方法，例如toUpperCase()</li><li>该方法运行并返回结果</li><li>调用完成之后，销毁这个对象包装器</li><li>JavaScritp引擎高度优化了这个过程</li></ul></li><li>构造器Number/String/Boolean仅限内部使用 <ul><li>alert(typeof new Number(&#39;123&#39;)) // &quot;object&quot;</li><li>alert(typeof Number(&#39;123&#39;)) // &quot;number&quot;</li></ul></li><li>调用形式 <ul><li>const m = 123; m.tString();</li><li>&#39;sss&#39;.toUpperCase()</li><li>1234..toString()</li><li>1.23.toFixed(1)</li><li>true.toString()</li></ul></li></ul><h3 id="number的方法-常规数字" tabindex="-1">Number的方法(常规数字) <a class="header-anchor" href="#number的方法-常规数字" aria-label="Permalink to &quot;Number的方法(常规数字)&quot;">​</a></h3><ul><li>创建Number书写的几种形式 <ul><li>let num = 1000000000</li><li>let num = 1_000_000_000</li><li>let num = 1e6; let num = 1e-6</li><li>let num = 0xff</li><li>let num = 0o377</li><li>let num = 0b11111111</li></ul></li><li>num.toString(base) <ul><li>base: 2~36，base为2时代表以二进制形式字符串显示；当base为36时，可以将一段较长的数字标识符转换成较短的； <ul><li>123456789..toString(36) // &#39;21i3v9&#39;</li></ul></li></ul></li><li>数字舍入 <ul><li>舍入到正数 <ul><li>Math.floor() 向左摄入</li><li>Math.ceil() 向右摄入</li><li>Math.round() 四舍五入</li><li>Math.trunc() 移除小数点之后的所有内容而没有内容 IE浏览器不支持</li></ul></li><li>舍入到小数后n位 <ul><li>乘除法 <ul><li>let num = 1.23456; alert(Math.round(num * 100) / 100); // 1.23</li></ul></li><li>toFixed(n) <ul><li>将数字舍入到小数点后n位，并返回字符串形式的结果 <ul><li>1.23456.toFixed(2) // &#39;1.23&#39;</li><li>1.23456.toFixed(3) // &#39;1.235&#39;</li></ul></li></ul></li></ul></li><li>其他数学方法 <ul><li>Matn.random() <ul><li>随机返回[0, 1)之间的随机数</li><li>从min到max的随机数 <ul><li>min + Math.random()*(max - min)</li></ul></li><li>从min到max的随机整数 <ul><li>Math.round(min - 0.5 + Math.random() * (max - min + 1))</li><li>Math.floor(min + Math.random() * (max + 1 - min))</li></ul></li></ul></li><li>Math.max(a, b, c, ...) &amp; Math.min(a, b, c, ...)</li><li>Math.pow(n, power)</li></ul></li></ul></li><li>isFinite(value) <ul><li>将value先转换为数字，如果是常规数字而不是Infinity/-Infinity/NaN，就返回true</li><li>常见的判断字符串是否是常规数字</li></ul></li><li>isNaN() <ul><li>将value先转换为数字然后判断是否是NaN</li><li>NaN === NaN // false， NaN不等于任何东西，包括它自身，但在Object.is()中的表现除外，Object.is(NaN, NaN)是true</li></ul></li><li>parseInt(str, radix) &amp; parseFloat(str) <ul><li>从字符串中读取数字，直到无法读取为止</li><li>某些情况下会返回NaN，例如parseInt(&#39;a234&#39;)，读取第一个字符就发生了错误</li><li>radix - 数字系统的基数</li></ul></li><li>不精确的计算 <ul><li>对带有小数点的数字会有精度损失，注意避免小数的相等性检查</li><li>有趣的事儿 <ul><li>alert(9999999999999999) // 10000000000000000</li><li>alert(1.35.toFixed(1)) // 1.4</li><li>alert(6.35.toFixed(1)) // 6.3</li><li>存在两个0：0和-0</li></ul></li></ul></li></ul><h3 id="string的方法" tabindex="-1">String的方法 <a class="header-anchor" href="#string的方法" aria-label="Permalink to &quot;String的方法&quot;">​</a></h3><ul><li>创建书写的形式 <ul><li>单引号 &amp; 双引号 <ul><li>不允许换行，但可以通过插入\\n实现转行</li></ul></li><li>反引号 <ul><li>允许换行</li><li>通过${}形式插入表达式</li><li>模板函数</li></ul></li><li>特殊字符：\\n \\r \\t \\uxxx</li></ul></li><li>str.length</li><li>读写字符串 <ul><li>读取方式 <ul><li>str[pos] 没找到就返回undefined</li><li>str.charAt(pos) 没找到就返回&#39;&#39;</li></ul></li><li>字符串不可修改，想要实现修改可以重新赋值给一个新的字符串</li></ul></li><li>改变大小写 <ul><li>str.toUpperCase()</li><li>str.toLowerCase()</li></ul></li><li>查找子字符串 <ul><li>str.indexOf(substr[, pos]) &amp; str.lastIndexOf(substr[, pos]) <ul><li>substr - 查找的子字符串；pos - 开始查找的位置</li><li>如果没有查找到返回-1；如果找到返回查找到的位置</li><li>想要从头找到尾 <ul><li><code>while(**(pos = str.indexOf(target, pos + 1))** !== -1) { alert(pos) }</code></li></ul></li><li>在if中使用注意 <ul><li>if(str.indexOf()) × 有可能出现位置为0情况</li><li>if(str.indexOf() !== -1) √</li><li>if(~str.indexOf()) ~str.indexOf() = -(str.indexOf()+1)</li></ul></li></ul></li><li>str.includes(substr[, pos]) <ul><li>pos - 开始搜索的位置；如果包含子字符串的话返回true，反之false；</li></ul></li><li>str.startsWith(subStr)</li><li>str.endsWith(substr)</li></ul></li><li>获取子字符串 <ul><li>str.slice(start[, end]) <ul><li>获取从start位置都end(不包含end)之间的子字符串</li><li>end被省略的话，就获取从start到最后的所有字符串</li><li>参数支持负数，负数的话从后往前数</li></ul></li><li>str.substring(start[, end]) <ul><li>与slice的使用基本一致，但它允许start大于end，该方法会默认进行调换</li><li>但不支持负数参数，负数被视作0</li></ul></li><li>str.substr(start[, length]) <ul><li>返回从start到给定length的结果</li><li>只有start参数支持负数</li></ul></li></ul></li><li>正确比较字符串 <ul><li>奇怪现象 <ul><li>小写字母大于大写字母</li><li>带有变音符号的比较</li></ul></li><li>正确的比较 <ul><li>根据语言比较字符串时：str.localeCompare(str2)，返回以下三种结果 <ul><li>-1 - str在str2前面</li><li>0 - 两者位置相同</li><li>1 - str在str2后面</li></ul></li><li>其他情况下：按数字代码比较 <ul><li>str.codePointAt(pos)</li><li>String.fromCodePoint(code)</li></ul></li></ul></li></ul></li></ul><h3 id="symbol" tabindex="-1">Symbol <a class="header-anchor" href="#symbol" aria-label="Permalink to &quot;Symbol&quot;">​</a></h3><ul><li>隐藏属性 <ul><li>const id = Symbol(&quot;id&quot;)</li><li>id.description</li><li>for ... in ... 和Object.keys() 无法遍历Symbol符号属性</li><li>Object.assign()克隆可以克隆到Symbol属性</li><li>从技术上讲，Symbol属性并不是完全隐藏的，Object.getOwnPropertySymbols(obj)和Reflect.ownKeys(obj)可以拿到Symbol属性</li></ul></li><li>全局Symbol <ul><li>Symbol.for()</li><li>Symbol.keyFor()</li></ul></li><li>系统Symbol <ul><li>Symbol.hasInstance</li><li>Symbol.isConcatSpreadable</li><li>Symbol.iterator</li><li>Symbol.toPrimitive</li><li>......</li></ul></li></ul><h2 id="引用类型的方法" tabindex="-1">引用类型的方法 <a class="header-anchor" href="#引用类型的方法" aria-label="Permalink to &quot;引用类型的方法&quot;">​</a></h2><h3 id="object-普通对象" tabindex="-1">Object(普通对象) <a class="header-anchor" href="#object-普通对象" aria-label="Permalink to &quot;Object(普通对象)&quot;">​</a></h3><h4 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h4>',21),l("ul",null,[l("li",null,"存储键值对：键 - 任何字符串或者Symbol; 值：任何类型"),l("li",null,[i("对象的增删改查 "),l("ul",null,[l("li",null,"访问/修改属性方式：点符号+方括号"),l("li",null,"删除 delete obj.prop"),l("li",null,'检查是否存在给定键的属性： "key" in obj'),l("li",null,[i("遍历对象 "),l("ul",null,[l("li",null,"for(let key in obj)"),l("li",null,"Object.keys/values/entries()"),l("li",null,[i("小技巧：转换对象 "),l("ul",null,[l("li",null,"let doublePrices = Object.fronEntries(Object.entries(prices).map(entry => [entry[0], entry[1] * 2]))")])])])])])]),l("li",null,"对象有特别的顺序：整数属性会被进行排序，其他属性则按照创建的熟悉怒显示"),l("li",null,[i('对象通过引用被赋值和拷贝，会互相影响，为实现"真正的拷贝"，常用方式 '),l("ul",null,[l("li",null,"浅拷贝 - Object.assign()"),l("li",null,"深拷贝 - 可直接使用各种第三方库")])]),l("li",null,[i("垃圾回收 "),l("ul",null,[l("li",null,"自动执行"),l("li",null,"可达性(可状态则一定是存在于内存中)"),l("li",null,"孤岛状态")])]),l("li",null,[i("构造函数 "),l("ul",null,[l("li",null,[i("概念：技术上就是常规函数，不过有两个约定 "),l("ul",null,[l("li",null,"命名首字母大写"),l("li",null,[i("使用new操作符执行 "),l("ul",null,[l("li",null,"创建空对象并分配给this"),l("li",null,"执行函数体，通常修改this，添加新属性"),l("li",null,"返回this的值")])])])])]),l("div",{class:"language- vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[l("code",null,[l("span",{class:"line"},[l("span",null,"function User(name) {")]),i(`
`),l("span",{class:"line"},[l("span",null,"  // this = {};(隐式创建)")]),i(`
`),l("span",{class:"line"},[l("span",null,"  this.name = name")]),i(`
`),l("span",{class:"line"},[l("span",null,"  this.isAdmin = false")]),i(`
`),l("span",{class:"line"},[l("span")]),i(`
`),l("span",{class:"line"},[l("span",null,"  // return this;(隐式返回)")]),i(`
`),l("span",{class:"line"},[l("span",null,"}")])])])]),l("ul",null,[l("li",null,[i("常见场景 "),l("ul",null,[l("li",null,"需要创建很多类似的对象，例如多个用户或菜单"),l("li",null,[i("封装构建单个对象的代码而无需将来重用 "),l("ul",null,[l("li",{"this.name":""},"let user = new function()")])])])]),l("li",null,[i("new.target - 在函数内部可使用new.target属性检查它是否被使用new进行调用了 "),l("ul",null,[l("li",null,"常规函数 - new.target -> undefined"),l("li",null,"new调用 - new.target -> 等于该函数")])]),l("li",null,[i("return的特殊行为 "),l("ul",null,[l("li",null,"构造函数默认没有return，任务只是将必要数据写入this并隐式返回this"),l("li",null,"当出现return时，return的是一个对象则返回该对象，其他情况一律返回this")])]),l("li",null,"添加方法")])]),l("li",null,[i("可选链 - 安全的访问嵌套属性，如果存在就返回对应属性值，不存在返回undefined "),l("ul",null,[l("li",null,[i("常见的三种使用形式 "),l("ul",null,[l("li",null,"obj?.prop"),l("li",null,"obj?.[prop]"),l("li",null,"obj.method?.()")])]),l("li",null,[i("使用注意 "),l("ul",null,[l("li",null,"不可滥用，仅当左侧部分不存在也可接受的情况下适合使用"),l("li",null,"可安全读取或删除但不能写入")])])])])],-1),a('<h4 id="对象属性类型" tabindex="-1">对象属性类型 <a class="header-anchor" href="#对象属性类型" aria-label="Permalink to &quot;对象属性类型&quot;">​</a></h4><ul><li>详见<a href="./对象属性类型.html">对象属性类型.md</a></li></ul><h4 id="原型" tabindex="-1">原型 <a class="header-anchor" href="#原型" aria-label="Permalink to &quot;原型&quot;">​</a></h4><ul><li>详见<a href="./原型.html">原型.md</a></li></ul><h3 id="基于object扩展的其他引用类型" tabindex="-1">基于Object扩展的其他引用类型 <a class="header-anchor" href="#基于object扩展的其他引用类型" aria-label="Permalink to &quot;基于Object扩展的其他引用类型&quot;">​</a></h3><h4 id="array" tabindex="-1">Array <a class="header-anchor" href="#array" aria-label="Permalink to &quot;Array&quot;">​</a></h4><ul><li>数组是特殊的对象，但数组更适用于需要顺序存储的场景</li><li>声明的两种形式 <ul><li>let arr = new Array([length]) 不推荐</li><li>let arr = [] √ 推荐</li><li>数组与对象的比较 <ul><li>扩展了对象，本质上也是可以使用对象的属性和方法的</li><li>但JavaScript引擎对数组的内部实现进行了特殊处理和优化，如果仍像常规对象那样使用数组，这有优化也就不生效了</li><li>数组常见的被误用的三种情况 <ul><li>制造空洞</li><li>添加非数字属性</li><li>倒序填充数组</li></ul></li></ul></li></ul></li><li>关于length <ul><li>返回数组中的元素总个数</li><li>可读可写 <ul><li>当给数组的length赋值一个小于数组元素个数的数字时，数字会被直接截断，所以常常利用这个特性清空数组 - arr.length = 0</li></ul></li></ul></li><li>新增特性 - 使用at方法获取最后一个元素 <ul><li>arr.at(-1)</li><li>需要polyfills</li></ul></li><li>数组的判断与比较 <ul><li>Array.is(arr)</li><li>不要用“==”运算符进行比较，可以遍历比较 <ul><li>比较arr1和arr2</li><li>return arr1.length === arr2.length &amp;&amp; arr1.every((item, index) =&gt; item === arr2[index])</li></ul></li></ul></li><li>数组的增删改查 <ul><li>双端队列特性 <ul><li>arr.push(...items) <ul><li>在数组尾端添加一个或多个元素</li></ul></li><li>arr.pop() <ul><li>在数组尾端取出一个元素并返回</li></ul></li><li>arr.shift() <ul><li>在数组首端取出一个元素并返回</li></ul></li><li>arr.unshift(...items) <ul><li>在数组首端添加一个或多个元素</li></ul></li><li>push、pop的性能要优于shift、unshift，因为前者的添加删除操作不需要移动索引</li></ul></li><li>瑞士军刀</li><li>arr.splice(start[, deleteCount, item1, ..., itemn]) <ul><li>从索引start处开始修改arr:删除deleteCount个元素并在当前位置插入ele1, ele2, ..., eleN。最后返回被删除的元素所组成的数组。</li></ul></li><li>删除元素 <ul><li>arr.splice(1, 1)</li></ul></li><li>替换元素 <ul><li>arr.splice(1, 1, &#39;Hi&#39;)</li></ul></li><li>插入元素 <ul><li>arr.splice(1, 0, &#39;we&#39;, &#39;are&#39;, &#39;family&#39;)</li></ul></li><li>arr.slice([start, end] <ul><li>常用来创建数组副本</li><li>let newArr = arr.slice()</li></ul></li><li>arr.concat(arg1, arg2, ...) <ul><li>将arr中的元素，arg1, arg2参数值复制到一个新的数组中</li><li>会将数组中的元素依次复制，如果是没有设置Symbol.isConcatSpreadable属性为true的类数组，只会被当作一个整体复制到新数组中。</li></ul></li></ul></li><li>数组遍历 <ul><li>for(let i = 0; i &lt; arr.length; i++)</li><li>for(let item of arr)</li><li>for(let item in arr) × <ul><li>能用但没必要，用在对象上可以，数组上最好不要用，会影响性能</li></ul></li><li>arr.forEach((item, index, array) =&gt; {}) <ul><li>没有返回值，就算有也会被抛弃和忽略</li></ul></li></ul></li><li>数组搜索 <ul><li>arr.indexOf(item[, pos]) &amp; arr.lastIndexOf(item[, pos])</li><li>arr.includes(item) <ul><li>includes可以正确处理NaN， 与indexOf不同</li></ul></li><li>arr.find((item, index, array) =&gt; {}) <ul><li>找到第一符合的元素就返回该元素，未找到返回undefined</li></ul></li><li>arr.findIndex((item, index, array) =&gt; {}) &amp; arr.findeLastIndex((item, index, array) =&gt; {}) <ul><li>找到第一个/最后一个符合的元素就返回该元素的索引，未找到就返回-1</li></ul></li><li>arr.filter((item, index, array) =&gt; {}) <ul><li>返回所有匹配的元素的一个新数组，如果没有匹配的返回空数组</li></ul></li></ul></li><li>数组转换 <ul><li>arr.map((item, index, array) =&gt; {}) <ul><li>常用来进行数组转换</li></ul></li><li>arr.reduce((accumulator, item, index, array) =&gt; {}, [initial]) &amp; arr.reduceRight()</li><li>arr.join([delim]) &amp; str.split([delim]) <ul><li>delim默认是&#39;&#39;空字符串</li></ul></li></ul></li><li>数组排序 <ul><li>arr.sort((a, b) =&gt; a - b) <ul><li>原位排序</li><li>比较函数可以返回任何数字，只要满足返回一个正数表示“大于”，一个负数表示“小于”就行</li></ul></li><li>arr.reverse() <ul><li>原位倒序</li></ul></li></ul></li><li>数组一些其他方法(覆盖场景大概1%吧) <ul><li>arr.copyWith(target, start, end)</li><li>arr.some(fn) &amp; arr.every(fn)</li><li>arr.fill(value, start, end)</li><li>arr.flat(depth) <ul><li>处理多维数组，将数组扁平化</li><li>arr.flat(infinity) - 不管是几维数组都扁平化成一维数组</li></ul></li><li>Array.of(item1, item2, ..., itemN) - 将一组值转换为数组</li><li>Array.from() - 将类数组对象转换为真正的数组</li></ul></li><li>数组Tips <ul><li>某些方法像splice，slice可以使用负向索引</li><li>数组的大多数方法都支持&quot;thisArg&quot; <ul><li>arr.find(func, thisArg);</li><li>arr.filter(func, thisArg);</li><li>arr.map(func, thisArg);</li></ul></li></ul></li></ul><h4 id="map-set-weakmap-weakset" tabindex="-1">Map&amp;Set(WeakMap&amp;WeakSet) <a class="header-anchor" href="#map-set-weakmap-weakset" aria-label="Permalink to &quot;Map&amp;Set(WeakMap&amp;WeakSet)&quot;">​</a></h4><ul><li>映射 <ul><li>Map - const map = new Map([[k1, v1],[k2, v2],...]) <ul><li>带键的数据项的集合，类似Object，但最大的不同的是Map允许任何类型的键，甚至可以使用对象作为键。</li><li>常见属性和方法，支持链式调用 <ul><li>map.set(key, value)</li><li>map.get(key) <ul><li>不推荐使用map[key]方式读取相应值，这个会丢失Map允许任何类型作为键的特性</li></ul></li><li>map.has(key)</li><li>map.delete(key)</li><li>map.clear()</li><li>map.size</li></ul></li><li>迭代 <ul><li>map.keys()</li><li>map.values()</li><li>map.entries() for...of默认情况迭代的就是这个</li><li>Map与Object的关联 <ul><li>迭代的区别 <ul><li>调用语法+返回值不同 <ul><li>map.keys() -&gt; 可迭代对象</li><li>Object.keys(obj) -&gt; 真正的数组</li></ul></li></ul></li><li>互相转换(Map ←→ Object) <ul><li>let map = new Map(Object.entries(obj))</li><li>let obj = Object.fromEntries(map) / Object.fromEntries(map.entries())</li></ul></li></ul></li></ul></li></ul></li><li>WekMap - const weakMap = new WeakMap() <ul><li>WeakMap的键必须是对象</li><li>WeakMap不支持迭代，所以只有以下方法 <ul><li>get, set, haa, delete</li></ul></li><li>特定场景使用 <ul><li>额外数据的存储</li><li>缓存</li></ul></li></ul></li></ul></li><li>集合 <ul><li>Set - const set = new Set([iterable]) <ul><li>值的集合，并且每个值只能出现一次</li><li>常见属性和方法 <ul><li>set.add(value)</li><li>set.has(value)</li><li>set.delete(value)</li><li>set.clear()</li><li>set.size</li></ul></li><li>迭代， 为了兼容Map，虽然set没有键但依然可以使用 <ul><li>set.keys()</li><li>set.values()</li><li>set.entries()</li></ul></li></ul></li><li>WeakSet <ul><li>只能添加对象</li><li>同样不支持迭代，只支持add, has, delete方法</li></ul></li></ul></li><li>Weak*的优点 <ul><li>对对象是弱引用，被它们引用的对象很容易被垃圾收集器移除，是以不支持迭代，clear(), size等属性与方法为代价</li></ul></li><li>映射和集合都是迭代顺序与插入顺序相同</li></ul><h4 id="function" tabindex="-1">Function <a class="header-anchor" href="#function" aria-label="Permalink to &quot;Function&quot;">​</a></h4><ul><li>详见<a href="./函数.html">函数.md</a></li></ul><h4 id="date" tabindex="-1">Date <a class="header-anchor" href="#date" aria-label="Permalink to &quot;Date&quot;">​</a></h4><ul><li>创建日期对象 <ul><li>new Date()</li><li>new Date(milliseconds)</li><li>new Date(datestring)</li><li>new Date(year, month, date, hours, minutes, seconds, ms)</li></ul></li><li>访问/设置日期对象 <ul><li>有UTC变体的 <ul><li>getFullYear()/setFullYear(year, [month], [date])</li><li>getMonth()/setMonth(month, [date]) <ul><li>注意，月份是<strong>从0到11</strong></li></ul></li><li>getDate()/setDate(date)</li><li>getHours()/setHours(hour, [min], [sec], [ms])</li><li>getMinutes()/setMinutes(min, [sec], [ms])</li><li>getSeconds()/getSeconds(sec, [ms])</li><li>getMilliseconds()/setMilliseconds(ms)</li><li>getDay()</li></ul></li><li>无UTC变体的 <ul><li>getTime()/setTime(milliseconds)</li><li>getTimezoneOffset()</li></ul></li></ul></li><li>自动校准特性 <ul><li>如果对日期对象设置超出范围的数字会自动校准</li><li>let date = new Date(2016, 1, 28); date.setDate(date.getDate() + 2) // 1 Mar 2016</li></ul></li><li>日期转化为数字，两个日期之前可以相减得到时间差</li><li>使用Date.now()可以避免创建中间日期对象，减少垃圾回收压力</li><li>Date.parse(str)解析指定格式(YYYY-MM-DDTHH:mm:ss.sssZ)的字符串并返回时间戳</li></ul><h3 id="iterable-object-可迭代对象" tabindex="-1">Iterable Object(可迭代对象) <a class="header-anchor" href="#iterable-object-可迭代对象" aria-label="Permalink to &quot;Iterable Object(可迭代对象)&quot;">​</a></h3><ul><li>可迭代对象 <ul><li>必须实现Symbol.iterator方法，会被for...of自动调用，也可主动调用</li></ul></li><li>迭代器 <ul><li><code>obj[Symbol.iterator]()</code>的结果被称为迭代器</li><li>迭代器必须有next()方法，返回<code>{ done: Boolean, value: any }</code></li></ul></li><li>内建可迭代对象 <ul><li>数组和字符串等属于内建可迭代对象，且字符串迭代器能够识别代理对(UTF-16扩展字符)</li></ul></li><li>Array.from(obj[, mapFn, thisArg]) <ul><li>类数组 - 有索引和length属性的的对象</li><li>可迭代对象和类数组对象都不属于真正的数组，借助Array.from()转化成真正的数组</li></ul></li></ul><h2 id="json" tabindex="-1">JSON <a class="header-anchor" href="#json" aria-label="Permalink to &quot;JSON&quot;">​</a></h2><h3 id="json-stringfy-value-replacer-spaces" tabindex="-1">JSON.stringfy(value[, replacer, spaces]) <a class="header-anchor" href="#json-stringfy-value-replacer-spaces" aria-label="Permalink to &quot;JSON.stringfy(value[, replacer, spaces])&quot;">​</a></h3>',17),l("ul",null,[l("li",null,"对象 -> JSON"),l("li",null,[i("参数说明 "),l("ul",null,[l("li",null,"value - 指定要编码的对象"),l("li",null,[i("replacer - 指定要编码的属性数组或映射函数(key, value) => {} "),l("ul",null,[l("li",null,"借助replacer参数过滤掉循环引用的属性"),l("li",null,[i("注意 "),l("ul",null,[l("li",null,"replacer 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。"),l("li",null,"第一个 (key, value) 对的键是空的，并且该值是整个目标对象，有需要的情况下可分析并替换/跳过整个对象。")])])])]),l("li",null,"spaces - 指定用于格式化的空格数量，该参数也可以指定为字符串")])]),l("li",null,[i("注意事项 "),l("ul",null,[l("li",null,[i("JSON与对象字面量的区别 "),l("ul",null,[l("li",null,"双引号：JSON中是没有单引号和反引号的，只有双引号；除了字符串必须双引号，属性名称也必须双引号")])]),l("li",null,[i("支持转换的数据类型 "),l("ul",null,[l("li",{"css-module":"."},"Objects"),l("li",null,"Arrays [ ... ]"),l("li",null,"strings"),l("li",null,"numbers"),l("li",null,"boolean values true/false"),l("li",null,"null")])]),l("li",null,[i("会被跳过的特定属性 "),l("ul",null,[l("li",null,"函数属性(方法)"),l("li",null,"Symbol类型的键和值"),l("li",null,"存储undefined的属性")])]),l("li",null,"重要限制：不得有循环引用")])]),l("li",null,[i("toJSON "),l("ul",null,[l("li",null,"类似toString，对象可提供toJSON方法来进行JSON转换。如果可用，JSON.stringify 会自动调用它。")])])],-1),l("h3",{id:"json-parse-str-reviver",tabindex:"-1"},[i("JSON.parse(str, [reviver]) "),l("a",{class:"header-anchor",href:"#json-parse-str-reviver","aria-label":'Permalink to "JSON.parse(str, [reviver])"'},"​")],-1),l("ul",null,[l("li",null,"JSON -> 对象"),l("li",null,[i("参数说明 "),l("ul",null,[l("li",null,"str - 要解析的JSON字符串"),l("li",null,[i("reviver - 可选的函数(key,value) => {}，该函数将为每个 (key, value) 对调用，并可以对值进行转换。 "),l("ul",null,[l("li",null,"例如在对日期的转换上，可将一个date的字符串转换为日期对象")])])])])],-1)]))}const f=t(n,[["render",s]]);export{p as __pageData,f as default};
