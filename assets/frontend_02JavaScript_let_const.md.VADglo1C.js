import{_ as t,c as o,o as e,ae as i}from"./chunks/framework.Cd-3tpCq.js";const _=JSON.parse('{"title":"let&const","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/02JavaScript/let&const.md","filePath":"frontend/02JavaScript/let&const.md"}'),a={name:"frontend/02JavaScript/let&const.md"};function n(c,l,s,r,p,u){return e(),o("div",null,l[0]||(l[0]=[i('<h1 id="let-const" tabindex="-1">let&amp;const <a class="header-anchor" href="#let-const" aria-label="Permalink to &quot;let&amp;const&quot;">​</a></h1><p>(1) 前情提要</p><ul><li>ES6新增了let命令声明变量、const声明一个只读的常量。</li><li>let、const提出的主要原因：块级作用域。由于ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景，比如： <ul><li>内层变量可能会覆盖外层变量。</li><li>用来计数的循环变量泄露为全局变量</li></ul></li></ul><p>(2) let与const的特性</p><ul><li>为JS新增了块级作用域，IIFE也变得不在必要了。</li></ul><blockquote><p>注意：for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><blockquote><p>for (let i = 0; i &lt; 3; i++) { let i = &#39;abc&#39;; console.log(i); } // abc // abc // abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p></blockquote></blockquote><ul><li>不存在<em>变量提升</em>，会出现暂时性死区。(var就有变量提升现象)</li><li>不可重复声明。(var就可以重复声明)</li><li>声明的全局变量或者全局常量，不再与顶层对象的属性挂钩。(var就与顶层对象的属性挂钩)</li></ul><blockquote><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p></blockquote><ul><li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li><li>const本质：<strong>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</strong>。简单类型数据地址和值统一，主要在于复合类型像数组对象之类的变量，引用地址不变，但其中的属性或者元素是可以改变的。</li></ul><p>(3) globalThis对象(<strong>ES2020</strong>)</p><ul><li>前端中顶层对象在各种实现里面是不统一的,使用起来受到极大局限 --浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 --浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 --Node 里面，顶层对象是global，但其他环境都不支持。</li><li>ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</li></ul>',11)]))}const b=t(a,[["render",n]]);export{_ as __pageData,b as default};
