import{_ as i,c as t,o,ae as s}from"./chunks/framework.Cd-3tpCq.js";const e="/assets/HTTPS%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E9%AA%8C%E8%AF%81%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%9B%BE%E8%A7%A3.DJi2YB7R.png",c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/05网络协议与安全/图解HTTPS流程.md","filePath":"frontend/05网络协议与安全/图解HTTPS流程.md"}'),n={name:"frontend/05网络协议与安全/图解HTTPS流程.md"};function r(a,l,_,T,p,A){return o(),t("div",null,l[0]||(l[0]=[s('<p><img src="'+e+'" alt="HTTPS加密解密验证和数据传输图解" loading="lazy"></p><ul><li><p>图解文字版：在使用HTTPS时需要保证服务端配置正确的安全证书</p><ul><li>客户端发送请求到服务端</li><li>服务端返回公钥和证书到客户端</li><li>客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端 <ul><li>如何验证合法性 <ol><li><strong>是否是信任的有效证书</strong>，浏览器内置了信任的根证书，看看web服务器上的证书是不是这些信任的根证书发的或者信任根的二级证书机构发的，还有<strong>是否过了有效期</strong>，<strong>是否被吊销</strong>；</li><li>证明对方是否<strong>持有证书的对应的私钥</strong></li></ol></li></ul></li><li>服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做对称加密秘钥对需要发送的数据进行对称加密</li><li>客户端在接收到加密后的数据使用秘钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户</li><li>SSL加密建立，加密通道成功建立，之后就是三次握手建立连接，四次挥手断开连接</li></ul></li><li><p>HTTPS中间人攻击过程如下：</p><ol><li>服务器向客户端发送公钥。</li><li>攻击者截获公钥，保留在自己手上。</li><li>然后攻击者自己生成一个【伪造的】公钥，发给客户端。</li><li>客户端收到伪造的公钥后，生成加密hash值发给服务器。</li><li>攻击者获得加密hash值，用自己的私钥解密获得真秘钥。</li><li>同时生成假的加密hash值，发给服务器。</li><li>服务器用私钥解密获得假秘钥。</li><li>服务器用加秘钥加密传输信息</li></ol><p>防范方法：</p><ol><li>服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性</li></ol></li></ul>',2)]))}const d=i(n,[["render",r]]);export{c as __pageData,d as default};
