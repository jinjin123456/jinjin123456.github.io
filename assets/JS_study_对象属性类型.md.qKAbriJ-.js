import{_ as e,c as i,o as l,R as s}from"./chunks/framework.BmksyVjO.js";const k=JSON.parse('{"title":"对象属性类型","description":"","frontmatter":{},"headers":[],"relativePath":"JS/study/对象属性类型.md","filePath":"JS/study/对象属性类型.md"}'),a={name:"JS/study/对象属性类型.md"},t=s(`<h1 id="对象属性类型" tabindex="-1">对象属性类型 <a class="header-anchor" href="#对象属性类型" aria-label="Permalink to &quot;对象属性类型&quot;">​</a></h1><h2 id="数据属性" tabindex="-1">数据属性 <a class="header-anchor" href="#数据属性" aria-label="Permalink to &quot;数据属性&quot;">​</a></h2><ul><li>属性描述符 <ul><li>value - 属性值</li><li>writable - 是否只可读</li><li>enumerable - 是否会在循环中列出</li><li>configurable - 该属性是否可以被删除，这些特性标志是否可以被修改 <ul><li><strong>configurable: false</strong>防止更改和删除属性描述符，但是允许更改对象的值，但是将configurable更改为false是不可逆的</li></ul></li><li>“常用方式”创建时默认都是true</li></ul></li><li>获取属性描述符集合 <ul><li><code>Object.getOwnPropertyDescriptor(obj, propertyName)</code></li><li><code>Object.getOwnPropertyDescriptors(obj)</code></li></ul></li><li>修改属性描述符 <ul><li><code>Object.defineProperty(obj, propertyName, descriptor)</code></li><li><code>Object.defineProperties(obj, descriptors)</code><ul><li>实现“更好“克隆 - <code>let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));</code></li><li>与<code>for..in</code>区别：不会忽略symbol类型和不可枚举的属性</li></ul></li><li>当使用描述器创建一个属性，它的标识默认是 <code>false</code></li></ul></li><li>设定全局密封对象(很少用) <ul><li><code>Object.preventExtensions(obj)</code> - 禁止向对象添加新属性</li><li><code>Object.seal(obj)</code> - 禁止添加/删除属性</li><li><code>Object.freeze(obj)</code> - 禁止添加/删除/更改属性</li><li><code>Object.isExtensible(obj)</code></li><li><code>Object.isSealed(obj)</code></li><li><code>Object.isFrozen(obj)</code></li></ul></li></ul><h2 id="访问器属性" tabindex="-1">访问器属性 <a class="header-anchor" href="#访问器属性" aria-label="Permalink to &quot;访问器属性&quot;">​</a></h2><ul><li><p>本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    get propName {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 当读取obj.propName时，getter起作用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    set propName {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 当执行obj.propName = value时，setter起作用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>属性标志</p><ul><li>get - 不带参数的函数，在读取函数时执行</li><li>set - 带一个参数的函数，在属性被设置时调用</li><li>enumerable</li><li>configurable</li><li><strong>注意</strong>：访问器属性的标志不可能出现value特性</li></ul></li><li><p>使用技巧</p><ul><li><code>getter/setter</code> 可以用作“真实”属性值的包装器，以便对它们进行更多的控制</li><li>兼容性： 允许随时通过使用 getter 和 setter 替换“正常的”数据属性，来控制和调整这些属性的行为</li></ul></li></ul>`,5),o=[t];function n(r,c,p,d,h,u){return l(),i("div",null,o)}const g=e(a,[["render",n]]);export{k as __pageData,g as default};
