import{_ as o,c as d,o as i,ae as c}from"./chunks/framework.Cd-3tpCq.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"offer/11多窗口方案.md","filePath":"offer/11多窗口方案.md"}'),l={name:"offer/11多窗口方案.md"};function a(n,e,t,r,s,u){return i(),d("div",null,e[0]||(e[0]=[c('<p>我要先快速浏览主进程的多窗口相关目录与文件（如 <code>src/main/nodeFn/windowPool/*</code>、<code>src/renderer/utils/createNewWin</code>、<code>AppSub</code> 等）以总结实现方案。接着会汇总窗口类型、创建流程、IPC 路由、窗口复用/池化、异常与重启策略等。 Ran tool Read file: src/main/nodeFn/windowPool/windowConfig.js Read file: src/main/nodeFn/windowPool/utils.ts Read file: src/main/nodeFn/windowPool/configData.ts Read file: src/main/nodeFn/windowPool/exceptionEvent.ts Read file: src/renderer/utils/createNewWin.ts Ran tool Read file: src/renderer/utils/createNewWin.js</p><h3 id="多窗口总体设计" tabindex="-1">多窗口总体设计 <a class="header-anchor" href="#多窗口总体设计" aria-label="Permalink to &quot;多窗口总体设计&quot;">​</a></h3><ul><li>主进程集中管理：通过 <code>src/main/nodeFn/windowPool/windowConfig.js</code> 的 <code>WindowConfig</code> 类统一管理主窗口与子窗口池（<code>mainWin</code> + <code>otherWin[]</code>）。</li><li>池化复用策略：维护“空闲窗口”与“忙碌窗口”，通过“空白路由”<code>BLANK_ROUTE/n</code> 标识空闲窗，限制空闲池上限 <code>WIN_BLANK_LEN</code>，优先复用空闲窗，必要时创建/回收。</li><li>路由即窗口实例：每个窗口以路由作为唯一标识（非多开），<code>isMultiWindow=true</code> 时允许相同路由多开。</li></ul><h3 id="创建与复用流程" tabindex="-1">创建与复用流程 <a class="header-anchor" href="#创建与复用流程" aria-label="Permalink to &quot;创建与复用流程&quot;">​</a></h3><ul><li>渲染进程发起： <ul><li>统一封装于 <code>src/renderer/utils/createNewWin.js</code>，如 <code>initWin</code>、<code>initPostTaskWin</code>、<code>initLogWin</code>、<code>initPickFloatWin</code>、<code>initDialogWin</code>、<code>initFloatBallWin</code>、<code>initBatchDataPickWin</code>。</li><li>通过 IPC 发送 <code>window-new</code>，附带窗口路由、尺寸、行为参数（如 <code>isIndependent</code>、<code>hasBeforeCloseHook</code>、<code>showLevitationBall</code> 等）。</li></ul></li><li>主进程处理： <ul><li><code>WindowConfig.listen()</code> 监听 <code>window-new</code> / <code>window-reset</code> / <code>window-close-allWin</code>。</li><li><code>createWindows(args)</code>： <ul><li>若同路由窗口存在且非多开：聚焦显示。</li><li>否则优先“复用空闲窗口”：<code>updateWin(winIndex, args, win, blankArgs)</code>；若复用的是独立窗，会“补充”一个空闲窗以维持池规模。</li><li>无空闲窗时：<code>addWin(args)</code> 新建 <code>BrowserWindow</code>。</li></ul></li><li>入口文件按路由分流：<code>loadPageByURL()</code> 根据路由映射至 <code>index.html</code> / <code>index_sub.html</code> / <code>index_posttask.html</code>。</li></ul></li></ul><h3 id="窗口池维护与回收" tabindex="-1">窗口池维护与回收 <a class="header-anchor" href="#窗口池维护与回收" aria-label="Permalink to &quot;窗口池维护与回收&quot;">​</a></h3><ul><li>定期重平衡：<code>resetWinPool()</code> → <code>validateWinPool()</code> 计算需要“重置为空闲”与“关闭”的窗口集合，执行 <code>pureWinPool()</code>。</li><li>定向重置：<code>resetWindow({ replaceRoute })</code> 按路由定向重置（关闭或回收到空闲），由渲染端 <code>replaceWin()</code> 发起。</li><li>空闲路由生成：<code>getBlankUrl()</code> 确保 <code>BLANK_ROUTE/n</code> 唯一性（按已用编号差集递补）。</li></ul><h3 id="窗口类型与关键参数" tabindex="-1">窗口类型与关键参数 <a class="header-anchor" href="#窗口类型与关键参数" aria-label="Permalink to &quot;窗口类型与关键参数&quot;">​</a></h3><ul><li>独立窗口 <code>isIndependent=true</code>： <ul><li>不参与池复用（如编辑器 <code>POST_TASK</code>），关闭或异常会触发单独的恢复策略。</li></ul></li><li>模态/父子窗口：支持 <code>parentId</code>、<code>modal</code>（当前项目多为无边框浮层/常驻窗的场景）。</li><li>常驻/浮层类窗：如悬浮球 <code>LEVITATION_BALL</code>、录制器浮层 <code>RECORDER_LEVITATION_WIN</code>、拾取提示 <code>PICK_FLOAT_TIP_WIN</code>，多为透明背景、置顶、跳过任务栏展示。</li></ul><h3 id="生命周期与异常恢复" tabindex="-1">生命周期与异常恢复 <a class="header-anchor" href="#生命周期与异常恢复" aria-label="Permalink to &quot;生命周期与异常恢复&quot;">​</a></h3><ul><li>通用事件绑定：<code>attachCommonEvent()</code>、<code>attachCustomEvent()</code>，处理 <ul><li>关闭前拦截 <code>hasBeforeCloseHook</code>、主窗关闭统一“二次确认”。</li><li>窗口最小化/聚焦触发悬浮球逻辑（托盘联动）。</li><li><code>did-finish-load</code>、<code>ready-to-show</code> 初始化同步、打开文件等。</li></ul></li><li>渲染进程异常：<code>exceptionEvent.ts</code><ul><li><code>render-process-gone</code>： <ul><li>若为编辑器窗 <code>POST_TASK</code>：按策略“销毁并重建”（失败次数阈值提示用户重启）。</li><li>其他窗：<code>reloadWindow()</code> 原路由重建。</li></ul></li><li><code>did-fail-load</code>：编辑器窗失败 2 次提示并回退主窗；其他窗直接重载。</li><li><code>unresponsive</code>：弹窗提示“再等等/重载/关闭”，支持热重建。</li></ul></li><li>退出策略：<code>closeAllWindow()</code>、<code>appQuit()</code> 杀掉 Python 主/接口进程与录制器子进程，确保干净退出。</li></ul><h3 id="ipc-与路由约定" tabindex="-1">IPC 与路由约定 <a class="header-anchor" href="#ipc-与路由约定" aria-label="Permalink to &quot;IPC 与路由约定&quot;">​</a></h3><ul><li>渲染端 → 主进程： <ul><li><code>window-new</code>（创建）、<code>window-reset</code>（重置）、<code>window-close-allWin</code>（全关）、<code>routeWinRemoveEvent</code>（解绑路由事件）。</li></ul></li><li>主进程 → 渲染端： <ul><li><code>showTargetWindow</code>、<code>window-isMaximized</code>、<code>window-showClose</code>、<code>engineStart</code>、<code>openFile</code>、<code>clearAll</code>、<code>clearEditProcessParams</code>、<code>createWinfail</code> 等。</li></ul></li><li>重要路由常量：<code>POST_TASK</code>、<code>LOG_DATA</code>、<code>LEVITATION_BALL</code>、<code>PICK_FLOAT_TIP_WIN</code>、<code>BATCH_DATA_PICK</code>、<code>DIALOG_FORM</code>、<code>BLANK_ROUTE</code>。</li></ul><h3 id="配置与安全" tabindex="-1">配置与安全 <a class="header-anchor" href="#配置与安全" aria-label="Permalink to &quot;配置与安全&quot;">​</a></h3><ul><li>默认配置：<code>windowsCfg</code>（<code>configData.ts</code>）集中定义窗口尺寸、透明度、可缩放、<code>webPreferences</code> 等。</li><li>入口切换：基于路由选择不同 HTML（独立进程和子页分离，降低互相影响）。</li><li>WebPreferences：<code>nodeIntegration: true</code>、<code>contextIsolation: false</code>（与现有工程兼容优先，注意后续可逐步收紧）。</li></ul><h3 id="典型场景" tabindex="-1">典型场景 <a class="header-anchor" href="#典型场景" aria-label="Permalink to &quot;典型场景&quot;">​</a></h3><ul><li>打开编辑器窗（独立窗）：<code>initPostTaskWin()</code> → <code>window-new</code> → 新建独立窗口，最大化/带关闭前拦截；异常自动重建。</li><li>打开日志窗（子窗）：<code>initLogWin()</code> → <code>window-new</code> → 透明置顶小窗；关闭不影响池规模。</li><li>打开拾取/悬浮类窗：<code>initPickFloatWin()</code>、<code>initFloatBallWin()</code> 均为浮层样式，定位与尺寸按屏幕动态计算。</li></ul><h3 id="方案优缺点" tabindex="-1">方案优缺点 <a class="header-anchor" href="#方案优缺点" aria-label="Permalink to &quot;方案优缺点&quot;">​</a></h3><ul><li>优点 <ul><li>高并发场景下的“复用+限额”控制，降低窗口频繁创建销毁的成本。</li><li>异常与未响应的自动化恢复策略，提升稳定性。</li><li>路由-入口分离，隔离复杂场景窗口的相互影响。</li></ul></li><li>注意点 <ul><li><code>nodeIntegration: true</code> 带来安全面需配合内部发行场景；外发需逐步隔离/沙箱化。</li><li>多路由多入口需谨慎维护映射，避免误入错误入口导致白屏。</li><li><code>existAutoHide</code>、<code>hasBeforeCloseHook</code> 这类行为参数需在调用端明确传递，避免体验不一致。</li></ul></li></ul><p>如需我输出“多窗口实现说明文档”成品文件或补充序列图/时序图，请告诉我要保存的文件名。</p>',20)]))}const _=o(l,[["render",a]]);export{h as __pageData,_ as default};
